# 垃圾回收(GC)

## GC 类型

1. Minor GC: 又叫 Young GC, 其只会在新生代执行
2. Major GC: 不等同于 Full GC, 只会在老年代执行
3. Full GC: 针对整个堆的收集

##### 注: 有 Full GC 的地方一定会有 Young GC, 但是有 Young GC 的地方不一定会有 Full GC

##### 注: GC 的过程会有一个暂停的过程, 不会产生新的对象, 称之为 Stop the world

## 内存分配策略

优先分配 Eden 区

大对象直接分配到老年代, 使用 -XX:PretenureSizeThreshold=6m 来设置大小阈值

长期存活的对象分配到老年代, 即超过多少岁(经历过多少次 Minor GC)会被移动到老年代, 使用 -XX:MaxTenuringThreshold=15
来设置存活阈值

空间分配担保, 检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小, 使用 -XX:+HandlePromotionFailure
来开启空间分配担保, 默认开启

动态对象年龄, 如果再 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半, 年龄大于或等于该年龄的对象就可以直接进入老年代,
使用 -XX:TargetSurvivorRatio 来设置阈值

## 对象是否为垃圾对象的判断方法

### 引用计数法

在对象中添加一个引用计数器, 当有地方引用这个对象的时候, 计数器 +1, 当失效的时候, 计数器 -1. 现在 GC 已不再使用.

##### 缺点

1. 性能差, 需要维护所有对象的引用数量
2. 循环引用的时候的问题

### 可达性分析

只要堆中的内存对象没有指向能到达 GCRoot 对象, 那么它就会被回收, 现在 GC 正在使用.

![013.png](img%2F013.png)

**GCRoot: 可以作为 GCRoot 的对象**

1. 虚拟机栈(局部变量表)
2. 方法区的类属性所引用的对象
3. 方法区的常量所引用的对象
4. 本地方法栈所引用的对象

## 回收策略(标记回收算法)

不同的分区都会有一个标识位, 用于标识不同的分区应该采用哪些标记算法

### 标记清除

分为两个阶段

1. 标记(Mark): 从根集合开始扫描, 对存活的对象进行标记
2. 清除(Sweep): 扫描整个内存空间, 回收未被标记的对象, 使用空间列表(free-list)记录这些区域

##### 优点

1. 不需要额外空间

##### 缺点

1. 效率问题(两次扫描, 耗时严重)
2. 内存碎片(会产生内存碎片)

### 标记压缩

分为两个阶段

1. 标记(Mark): 从根集合开始扫描, 对存活的对象进行标记
2. 压缩(Compact): 再次扫描, 并往一端滑动存活对象

##### 优点

1. 没有内存碎片, 可以利用 bump

##### 缺点

1. 需要移动对象的成本, 非常耗时

### 标记清除压缩

标记清除和标记压缩的结合

### 复制算法

从 eden和from 中找到存活对象拷贝到 to 中, 然后清空 eden和from, from,to 交换身份

Minor GC 会把 Eden 中的所有活的对象移动到 Survivor 区, 如果 Survivor 区中放不下, 剩下的活的对象被移动到 Old 区, 收集后
Eden 为空

对象每经过依次 Minor GC, 其年龄 +1, 当对象年龄到达 15 岁就会被移动到老年代

执行过程

1. Minor GC 会将 Eden和Survivor from 两个区中还存活的对象收集复制到 Survivor to 区
2. 清空 eden 和 Survivor from
3. Survivor 中的 from和to 身份互换

##### 优点

1. 没有标记清除的过程, 效率高.
2. 有内存碎片, 可以利用 bump-the-pointer 实现快速内存分配.

##### 缺点

1. 需要双倍空间
2. 复制耗时(只能在新生代使用)

## 垃圾回收器类型

![014.png](img%2F014.png)

1. Serial(新生代)
2. ParNew(新生代)
3. Parallel Scavenge(新生代)
4. CMS(老年代)
5. Serial Old(MSC)(老年代)
6. Parallel Old(老年代)
7. G1(既可以在新生代使用, 也可以在老年代使用)
8. ZGC

### Serial

是一种单线程的垃圾收集器, 在工作的时候会暂停所有的用户线程(Stop the world), 整个业务会停顿, 直到垃圾回收结束.
在工作过程中只有一个线程进行垃圾回收的工作. 仅作用于新生代.

主要用于客户端, 在内存比较小的情况下效率是非常高的, 因为是单线程模式, 没有线程上下文切换的开销, 暂停时间非常短,
原因是内存非常的小.

老年代可选搭配: CMS, Serial Old(MSC)

### ParNew

是一种多线程的垃圾收集器, 与 Serial 的代码百分之九十以上是完全一样的, 差别在于在进行垃圾回收的时候是多个线程进行处理的.
仅作用于新生代.

低延迟, 因为是多线程处理的, 尽量缩短 GC 的运行时间, 追求的是更少的停顿时间.

老年代搭配: CMS, Serial Old(MSC)

### Parallel Scavenge

并行的垃圾收集器, JDK7 默认的. 仅作用于新生代.

适合在后台如计算任务这类的情况下, 吞吐量是非常高的. 追求的是吞吐量.

##### 优点

1. 作用于新生代(新生代收集器), 使用复制算法
2. 多线程收集器, 并行执行
3. 达到可控制的吞吐量
    1. 吞吐量, CPU 用于运行用户代码时间与 CPU 消耗总时间的比值
    2. 吞吐量 = 执行用户代码时间 / (执行用户代码时间 + 垃圾回收使用的时间)
    3. -XX:MaxGFPauseMillil, 用于设置垃圾收集停顿时间, 如果设置的过低(同时把新生代设置成该值所能处理的一个范围), 即新生代过小,
       那么会导致新生代经常会满, 满了就会经常的发生 gc, 会严重影响效率
    4. -XX:GCTimeRatio, 吞吐量大小(0, 100), 默认 99, 代表 99% 的时间是用于执行用户代码

##### 执行过程

1. Stop the world
2. 充分利用 CPU 多核的能力来达到高性能, 即让多个 GC 线程并行执行
3. 执行完成结束 Stop the world

老年代搭配: Serial Old(MSC), Parallel Old

### CMS(Concurrent Mark Sweep)

并发的垃圾收集器, 使用标记清除的方式. 作用于老年代. 是一种标记清除的收集算法.

最大的目标是降低停顿时间(其中有的过程是并发工作的).

##### 优点

1. 并发收集
2. 低停顿

##### 缺点

1. 占用 CPU 资源, 因为在并发标记的过程中 GC 线程是与用户线程并发执行的, 会占用 CPU 资源, 且会带来 CPU 上下文切换的开销
2. 无法处理浮动垃圾
3. 出现 Concurrent Mode Failure, 因为是运行在老年代, 在清理的过程中会产生浮动垃圾, 导致老年代放不下了, 就会出现这种异常,
   一旦产生这种问题, CMS 就会被放弃使用进而切换成 Serial Old(MSC), 单线程的, 性能很差
4. 空间碎片, 因为使用标记清除的方式来清理垃圾, 所以会产生空间碎片

新生代搭配: Serial, ParNew

##### 执行过程

### G1

新生代和老年代都可以使用, 弱化了新生代和老年代的概念, 通过 Region 来进行分配, 通过给 Region 添加标记来从逻辑上区分是属于哪个分代.
标记整理和标记压缩.

##### 优点

1. 既可以并发, 也可以并行
2. 分代收集, 可以用于新生代, 也可以用于老年代
3. 空间整合, 标记压缩算法
4. 可预测的停顿, 可以设置一个时间, 在这个时间内完成 GC 的工作

##### 执行过程

1. 初始标记, 停顿用户线程, GC 线程并发标记
2. 并发标记, 与用户线程并发运行, 执行标记的工作
3. 最终标记, 停顿用户线程, 执行 Remark, 打分
4. 筛选回收, 把打分最高的几个块进行回收

##### 内存模型

整个堆内存被分成了很多个小的区域(Region), 被使用的叫做 Used Region, 未被使用的叫做 Free Region

1. 多个新生代空间块
2. 多个幸存区空间块
3. 多个老年代空间块
4. 巨形对象, 非常大的对象, 可以设置一个阈值
5. 空闲空间, 未被使用的空间

##### 内存模型底层实现

GC 回收的最小单位是 Region. Region 中又被划分成了很多个 Card(卡片), 一个卡片默认为 512 字节(Byte). 会有一个 Global Card
Table, 用于记录 Card 的分配使用情况.

##### 分代模型

1. 新生代(Young Generation)
    1. 伊甸园(Eden), TLAB(Thread Labs, 本地线程分配缓冲区) 会在此空间分配, TLAB 的好处是不用跟别的线程竞争资源了,
       减少线程之间的开销
    2. 幸存区(Survivor), 一般情况下 PLAB 不会放在该空间, 在有些实现的情况下也会放进来
2. 老年代(Old Generation), 对象晋升到老年代之后, 其 TLAB 也会转移过来, 晋升为 PLAB(Promotion Labs). GC 也是一个线程,
   其也会被分配一些空间大小, 被称为 GCLAB(GC Labs)

##### 分区模型

1. 在 G1 的分区模型中, Region 和 Region 是可以存在引用的(其中的对象互相引用)
2. Young Region 和 Old Region 之间也可以存在引用(其中的对象互相引用), 这些引用需要被保存到一个 RSet(Remember Set) 中

##### 收集集合(CSet)

收集集合(CSet)代表每次 GC 暂停时回收的一系列目标分区

CSet分为以下两种

1. of young collection: 新生代需要回收的 region 信息
2. of mixed collection: 混合(新生代和老年代都记录)需要回收的 region 信息

最终 GSet 中记录的 Region 区会被回收

### ZGC

Z 是最后一个英文字母, 代表最终的意思, ZGC 意思就是最终的 GC 或最牛逼的 GC 的意思.

ZGC 只能工作在 64 位的机器上, 在 64 位中, 理论上来说只会用 42 位来存储指针信息, 剩下的 22 位用来存储 GC 收集的信息,
即在指针上做标记.

##### 原理

ZGC 在指针上做标记, 在访问指针时加入 Load Barrier(读屏障), 比如当对象正在被 GC 移动,
指针上的颜色就会不对, 这个屏障就会先把指针更新为有效地址再返回, 也就是, 永远只有单个对象读取时有概率被减速,
而不存在为了保持应用与 GC 一致而粗暴整体的 Stop the world

##### 并发执行的保证机制

1. Load Barrier(读屏障):  保证在加载某个内存地址的数据之前, 所有之前的内存操作都已经完成. 主要用于防止 GC 在工作的过程中被读取了.
2. Colored Pointer(着色指针): GC 在工作的过程中会对标识位进行修改操作, 在操作之前会先加入读屏障

##### 内存模型

1. 指针使用 64 位进行存储
2. 其中 32 位用于存储对象地址(真实的指针信息)
3. 剩下的 22 位中只用了其中 4 位, 用于做指针标记(垃圾标记), 即标识位
    1. Finalizable
    2. Remapped
    3. Marked1
    4. Marked0
4. 剩余的 18 位是没有被使用的

##### 内存结构

ZGC 将堆划分为 Region 作为清理,移动以及并行 GC 线程工作分配的单位(与 G1 差不多).

分别有 2MB,32MB,N * 2MB 三种 Size Groups, 动态的创建和销毁 Region, 动态的决定 Region 的大小(G1 的大小可伸缩)

##### 回收过程

1. 初始停顿标记(Pause Mark Start), 停顿 JVM, 标记 Root 对象(GCRoot 直达), 对象会被标记为 live
2. 并发标记(Concurrent Mark), 并发的递归标记其它对象, 找到下级可达对象, 也标记为 live
3. 移动对象(Relocate), 对比发现找到过期对象, 即找到需要被清理的对象所在的 Region, 然后把这些 Region 中存活的对象移动到一个新的
   Region. 移动过程中有个 forward table 来记录这种转向.
4. 修正指针(Remap), 最后将指针更新指向新地址. 即将被移动的对象重新关联到它的引用那里去, 如 A 引用了 B, B 被移动了, 移动之后
   A 要重新指向 B 的新地址.
5. 清空转向表(Forwarding Tables Freed)

最长的停顿时间是 10ms, 因为只有在第一阶段进行停顿 JVM, 而且只用来标记 Root 对象, 而其它阶段都没有进行停顿 JVM 的操作.
