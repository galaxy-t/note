# 对象的创建过程

![008.png](img%2F008.png)

1. new 类型: 去常量池找到这个类名的引用, 如果没有找到会进行类的加载
2. 根据 new 的参数在常量池中定位一个符号引用
3. 如果没有找到这个符号引用, 则执行类的加载,验证,初始化
4. 虚拟机为对象分配内存
5. 将分配的内存初始化为零值
6. 调用对象的 init 方法(构造方法, 初始化块)

## 内存分配方式

1. 指针碰撞: 对于连续内存来说, 会有一个指针指向已分配和未分配的分隔位置, 要新分配内存, 指针就会进行移动, 这就叫做指针碰撞
2. 空间列表: 对于非连续内存来说, 已分配的内存一块一块的随机分布在内存上, 这时候就需要记录这些已分配的内存位置,
   已分配的对象记录就叫做空间列表

## 线程安全性问题

1. 线程同步(基本不用这种方式)
2. 本地线程分配缓冲(TLAB): 堆上会为每个线程分配一块空间, 每个线程都会在自己的空间上创建

![009.png](img%2F009.png)

## 对象在内存中的数据结构

![010.png](img%2F010.png)

**注: Padding(对齐填充), 8 个字节的整数倍, 虚拟机规范里面要求, 整个对象的大小应该是 8 个字节的整数倍,
但是实例数据是不受控制的(会有所差异), 这个时候就需要 Padding 来进行填充**

## Hotspot 虚拟机对象头 Mark Word

![011.png](img%2F011.png)

## 对象的访问定位

1. 使用句柄, 对象的引用指向了一个句柄池, 句柄池再指向实际的内存对象.
    * 优点, 内存对象发生变化不影响 java 应用程序, 由句柄池来进行处理
    * 缺点, 需要访问两次
2. 直接指针, HotSpot 使用的是直接指针, 引用直接指向内存空间
    * 优点, 速度快
    * 缺点, 内存发生变化引用需要重新指向
