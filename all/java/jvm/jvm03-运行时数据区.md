# 运行时数据区(Runtime Data Area)

包含以下五块内容

1. 方法区(Method Area)
2. 堆(Heap)
3. Java 栈(Java Stack)
4. 本地方法栈(Native Method Stack)
5. 程序计数器(Program Counter Register)

Java 栈,本地方法栈,程序计数器, 这三个是每个线程独有的, 不属于 GC 的管辖范围.

方法区和堆是公共的, 会被 GC 优化.

GC 95% 以上的时间都会用于处理堆, 还有少部分时间会在方法区进行一些处理.

## 本地方法栈(Native Method Stack)

它的具体做法是 Native Method Stack 中登记 native 方法, 在 Execution Engine 执行时加载本地方法库

## 程序计数器/PC 寄存器

每个线程都有一个程序计数器, 是线程私有的, 就是一个指针, 指向方法区中的方法字节码(用来存储指向下一条要执行的指令的地址,
也就是将要执行的指令代码), 由执行引擎读取下一条指令.

是一个非常小的内存空间, 几乎可以忽略不计.

如果线程执行的是 java 方法, 记录的是正在执行的虚拟机字节码指令的地址.

如果是 native 方法, 这个计数器值为 undefined.

## 栈(Stack)

栈也叫栈内存, 主管 Java 程序的运行, 是在线程创建时创建, 它的生命周期跟随线程的生命周期, 线程结束栈内存也就会被释放.

对于栈来说不存在垃圾回收问题, 只要线程一结束栈就 Over, 生命周期和线程一致, 是线程私有的.

8 种基础类型的变量 + 对象的引用变量 + 实例方法都是在函数的栈内存中分配.

### 栈帧数据(Frame Data)

一个栈里有多个栈帧.

### 栈溢出

StackOverflowError, OutOfMemory

## 方法区(Method Area)

JVM 规范将方法区描述为堆的一个逻辑部分, 但它还有一个别名叫做 Non-Heap(非堆), 目的就是要和堆区分开来.

方法区是一个接口, 是一个定义, 不是一个实现.

在 JDK8 之前会有一个永久代的东西, 这就是方法区的实现.

JDK8及之后有了元空间, 其地位等同于永久代, 也是一种方法区的实现.

所以也可以将方法区成为永久代或元空间.

方法区是被所有线程共享, 此区属于共享区间.

此区域是一个常驻内存区域, 它存储的是运行环境所必须的类等信息, 被装载进此区域的数据是不会被垃圾回收器回收掉的(也会,
只不过很少), 关闭 JVM 才会释放此区域所占用的内存.

### 存储内容

1. 类信息
    1. 类的版本
    2. 字段
    3. 方法
    4. 接口
2. 静态变量
3. 常量
4. 类信息(构造方法/接口定义)
5. 运行时常量: 编译器生成的各种字面量(基础数据类型的值)和符号引用(变量名), 这些将在类加载后存放到常量池(
   常量池是方法区的一部分)中

### java.lang.OutOfMemoryError: PermGen space

说明是 Java 虚拟机堆永久代 Perm 内存设置不够.

一般出现这种情况, 都是程序启动需要加载大量的第三方 jar 包, 例如: 在一个 Tomcat 下部署了太多的应用,
或者大量动态反射生成的类不断被加载, 最终导致 Perm 区被占满.

###          

JDK1.6 及之前, 有永久代, 常量池 1.6 在方法区

JDK1.7 有永久代, 但已经逐步去永久代, 常量池 1.7 在堆

JDK1.8 及之后, 无永久代只有元空间, 常量池 1.8 在元空间

##### 综上, 在 JDK8及之后的版本中方法区被分为两块, 元数据区和常量池

## 堆(Heap)

![007.png](img%2F007.png)

一个 JVM 实例只存在一个堆内存, 堆内存的大小是可以调节的.

类加载器读取了类文件后, 需要把类,方法,常量放到堆内存中, 保存所有引用类型的真实信息, 以便执行器执行.

堆内存分为三大块

1. 新生代(Young Generation Space)(Young/New)
    1. 伊甸园(Eden): 所有新创建的对象都会放入该区, 经过一次 GC 之后幸存的内容会放入到存活区, 大对象(
       超过放入伊甸园区的限制的对象)会直接进入老年代. 开启逃逸分析也不会直接进入伊甸园区.
    2. 幸存区(Survivor)
        1. from: 存活区的内容都会存放在该区域, 当需要清理的时候会将需要被清理掉的内容标记, 将需要保留的整体复制到 to,
           然后清空该区, 该区转换为 to 区
        2. to: 默认是空的, 当 from 的内容复制过来之后该区变更为 from 区
2. 老年代(Tenure generation space)(Old/Tenure)
3. 方法区(永久代/元空间)(Permanent Space)(Perm): 又被成为非堆, 可以理解为堆外空间

##### 以上只是逻辑上的概念, 实际上就是一个堆内存(方法区也位于堆内存中)

## 栈,堆,方法区 的交互关系

![012.png](img%2F012.png)

HotSpot 是使用只指针的方式来访问对象, Java 堆中会存放访问类元数据的地址, reference 存储的就直接是对象的地址.
