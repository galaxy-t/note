# 类加载机制

虚拟机把描述类的数据从 Class 文件加载到内存, 并对数据进行校验, 解析和初始化, 最终形成可以被虚拟机直接使用的 Java 类型,
这就是虚拟机的类加载机制.

在 java 中类是懒加载的

## 加载源

1. 文件
    1. class 文件
    2. jar 文件
2. 网络
3. 计算生成二进制流
4. 数据库
5. 其它文件生成
    1. jsp

## 懒加载

```
    public class User {

        static {
            System.out.println("静态代码块......");
        }
    
        public User() {
            System.out.println("构造方法.......");
        }
    }
```

在以上代码中, 当程序运行的时候, User 类并不会被直接加载, 而是在他首次被调用的时候才会被加载,

在加载的时候的其中的初始化顺序为

1. 先执行静态代码块
2. 再执行构造方法

## 类加载的生命周期

    <clinit>: 类初始化
    <init>: 对象初始化

    符号引用: 通过变量进行引用
    直接引用: 直接连接到其所在地址

1. 加载
    1. 从加载源将类文件读取出来
    2. 会根据 class 文件或流里面的内容分配好相应的内存空间
    3. 生成对应类型的 Class 对象, 如: Class<User>, 这些 Class 对象会被放在方法区(或元空间)
2. 连接
    1. 验证, jvm 为了保证再运行环境的安全性, 会对字节码文件进行验证(沙箱安全机制)
        1. 字段, 包名, 方法是否有重复等
        2. 是否继承了 final 类
        3. 字节码是否符合 jvm 规范等
    2. 准备, 准备阶段正式为类变量分配内存并设置变量的初始值. 这些变量使用的内存都将在方法区中进行分配.
    3. 解析, 解析阶段是虚拟机将常量池中的方法引用(符号引用)替换为直接引用的过程, 解析的是类或接口.
        1. 字段解析
        2. 类方法解析
        3. 接口方法解析
3. 初始化: 初始化是执行 <clinit>() 方法的过程, 即调用类的构造方法
4. 使用
5. 卸载

## 基于问题分析

```java

public class Test2 {

    static {                                // 在准备阶段被执行
        i = 9;                              // 不会报错, 因为这行代码是在方法区变量表中处理的, 编译加载的时候就已经存在于变量表中了
        System.out.println(i);              // 会报错, 而且报错在解析过程(加载过程 2.3), 因为这是一个取值的过程, 取值的时候是去访问内存地址的, 但是 i 的内存还没有被分配, 所以会报错
    }

    public static void main(String[] args) {

    }

    static int i = 1;                       // 首先在编译加载阶段就会被放到变量表中, 然后被赋零值, 此时在变量表中 i 等于 0, 在准备阶段执行静态代码块时先会将 i = 1 进行处理
}

```

以上代码会报错

跟 类的加载顺序和静态代码的解析加载顺序 有关

1. 在编译加载阶段就已经知道 i 这个变量的存在了, 此时会将其放到方法区的变量表中且其初始值为 0
2. 在准备阶段执行静态代码的时候(静态代码是在准备阶段执行的)
    1. i = 9; 是一个赋值操作, 该操作会直接操作变量表, 所以不会有问题
    2. System.out.println(i); 需要去读取内存并执行打印, 但是 i 此时并没有被放到内存中去, 所以报错. 因为静态代码的执行顺序是从上到下的,
       准备阶段会从上到下的执行一个 class 文件的静态代码, 该执行的执行, 该分配内存的分配内存, 但是因为在写法上静态代码块在
       i 的定义(static int i = 1;)的上面, 赋值不会有问题, 但是打印却会报错, 因为 i 还没有被分配内存空间. 如果将 static
       int i = 1; 放到静态代码块的上边, 就不会报错了, 因为在准备阶段, i 会首先被分配内存空间, 然后静态代码块才会被执行,
       此时 i 已经被放到内存中去了, 所以打印代码就不会报错了.

以上类注释掉 System.out.println(i); 编译然后看字节码指令如下

```text

{
  static int i;
    descriptor: I
    flags: ACC_STATIC

  public com.galaxyt.test01.Test2();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1                                                            # stack=1(操作数栈深度为 1), locals=3(局部变量有 3 个), args_size=1(表示有一个参数, 如果是实例方法, 这个值应该是参数的数量 +1, 因为局部变量默认带一个 this 的参数)
        0: aload_0
        1: invokespecial #1                  // Method java/lang/Object."<init>":()V            # 初始化块, 即构造方法
        4: return
      LineNumberTable:
        line 3: 0                                                                               # 变量表中会有一个等于 0 的变量, 这就是 i 这个变量

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
        stack=0, locals=1, args_size=1                                                          # 栈中并没有这个变量, System.out.println(i) 会去栈中查找, 栈中没有所以报错
            0: return
        LineNumberTable:
            line 12: 0

    static {};                                                                                   # 静态代码的处理, 包括静态代码块和静态变量都会在这里
        descriptor: ()V
        flags: ACC_STATIC
        Code:
            stack=1, locals=0, args_size=0
                0: bipush        9                                                               # 9 这个数字压栈
                2: putstatic     #7                  // Field i:I                                # 出栈并赋值给静态变量 i
                5: iconst_1                                                                      # 常量 1 压栈
                6: putstatic     #7                  // Field i:I                                # 出栈并赋值给静态变量 i
                9: return
            LineNumberTable:
                line 6: 0
                line 14: 5
}

```

由上述字节码文件可以看出, 在编译的过程, 所有的变量都是先赋值为零值的, 然后在加载过程中将变量统一放到方法区的变量表中,
在准备阶段会执行静态代码块(编译器会按照由上到下的顺序将所有的静态变量及静态代码块进行打包, 打包成一个静态代码块,
即静态变量的定义会被打包成一句赋值的操作, 因为在定义的时候可以有赋值操作)然后执行

static 块的代码只会被执行一次, 即使有高并发加载一个类的情况下也只会被执行一次,
因为静态代码块在执行之前 jvm 会做一个加锁的操作, 当然这个锁的效率是很高的, 所以其只会被执行一次,
但是, 只有当静态代码块被执行完毕, 所有的线程的初始化动作才会被执行, 即在高并发的情况下, 如果静态代码块中有一些延迟操作,
即使它只会被执行一次, 其它的线程的创建过程也需要等待其执行完成才会继续
