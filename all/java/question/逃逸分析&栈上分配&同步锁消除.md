# 逃逸分析&栈上分配&同步锁消除

## 逃逸分析

一个对象有没有逃逸说的是这个对象被创建出来之后最终这个对象是否出去了当前方法的范围

### 逃逸示例

```text
public User getUser() {
    return user == null ? new User() : user;
}
```

```
public void setUser() {
    this.user = new User();
}
```

### 没有逃逸的示例

```
public void test() {
    User user = new User();
}
```

##### 注: 只要是对象有被方法外部或者全局引用到那肯定会存在逃逸

### 逃逸状态

1. 全局逃逸(GlobalEscape): 一个对象的作用范围逃出了当前方法或者当前线程
    1. 一个对象的引用是赋值给了一个类变量
    2. 存储在一个已经逃逸的对象当中
    3. 这个对象的引用作为方法的返回值返回给了调用方法
2. 参数逃逸(ArgEscape): 一个对象被作为方法参数传递或者被参数引用, 但在调用过程中不会发生全局逃逸, 这种状态可以通过分析被调方法的二进制代码确定
3. 没有逃逸(NoEscape): 顾名思义, 就是没有逃逸

## 栈上分配

没有逃逸的对象可能会会在栈空间进行分配, 称之为栈上分配. 即对象被存储到栈上而不是堆上.

栈上分配速度很快, 如果所有的对象都要放到堆上, 那么无论从调用还是其它的方面来看都会增加操作.

栈上是不会存在 GC 的, 用完了就清理掉了, 非常方便.

### 标量替换

若一个数据已经分解到不能再小了, 这种称为标量. 如果可以再继续分解则称为聚合量.

标量替换就是将一个 java 对象拆散, 根据程序的访问情况, 将其用到成员变量恢复为原始类型来访问, 称为标量替换.

## 同步锁消除

如果 jvm 通过逃逸分析发现某个对象只能被一个线程访问到, 则访问这个对象的时候可以不加同步锁.

如果程序中使用了 synchronized 锁, 则 jvm 会将 synchronized 锁消除.

##### 注: 这种情况仅针对 synchronized 锁, 而对于 Lock 锁 jvm 并不能消除.
