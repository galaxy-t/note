# Volatile

    Java 中用于保证变量的可见性和顺序性的关键字

    volatile 只能保证变量的内存可见性, 但并不能保证其原子性, 即它不能保证高并发时对这个变量操作是线程安全的

## 可见性

    在定义一个变量之后, 这个变量的值会存在于主内存中, 当有不同的线程想要操作这个变量的时候, 需要先从主内存中拷贝一个副本到自己线程的内存中,
    然后该线程修改的是自己内存的副本, 修改之后再写入到主内存中去, 
    
    而可见性就是对修改和写入加锁, 即修改之后写入内存的这段操作是线程安全的, 这样在一个线程修改之后, 其它线程再拿到这个变量的时候是最新的
    不存在一个线程修改完副本, 然后其它线程又修改自己的副本然后先写入到主内存, 然后第一个线程再写入到主内存的情况

## 线程不安全

    假设有 A,B 两个线程, 有一个被 volatile 修饰的变量 v(volatile int v = 100), 
    A 拿到了 v 之后进入了线程阻塞, 即 A 拷贝了 v 的一个副本,
    B 也拿到了 v 之后对其 加1, 加1操作会立刻写入主内存, 但是并不会同步到其它线程的副本中, 
    A 再对 v 进行 加1 操作, 然后又写入到了主内存, 此时就会出现线程不安全的情况

## 

    volatile 只能保证一个线程再拿变量的时候这个变量是最新的值, 但是不能保证拿到这个变量和对其操作之间, 这个变量会不会进行变化

    volatile 关键字对于基本类型的修改可以再随后多个线程的读保持一致, 但是对于引用类型, 仅仅保证引用的可见性, 并不保证引用内容的可见性