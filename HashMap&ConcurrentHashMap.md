# 其它知识点

## 数组

    采用一段连续的存储单元来存储数据, 对于指定下标的查找, 复杂度为 O(1), 通过给定值进行查找, 需要遍历数组, 复杂度为 O(n)

## 线性链表

    对于链表的新增, 删除等操作(在找到指定操作位置后), 仅需要处理节点间的引用即可, 时间复杂度为 O(1), 
    而查找操作需要遍历链表逐一进行对比, 复杂度为 O(n)

## 二叉树

    对一颗相对平衡的有序二叉树, 对其进行插入, 查找, 删除等操作, 平均复杂度均位 O(logn)

## 哈希表

    相对上述几种数据结构, 在哈希表中进行添加,删除,查找等操作, 性能十分之高, 不考虑哈希冲突的情况下, 仅需一次定位即可完成, 时间复杂度为O(1), 
    实际上就是将对应的值通过某种函数映射到数组中的某个位置, 通过数组下标一次定位即可完成

## 哈希冲突

    哈希算法存在一个缺点就是哈希冲突, 如将两个值进行hash后得到的地址是相同的. 所以 HashMap 就是采用了链地址法, 即 数组+链表 的方式


# HashMap

    HashMap 的主干是一个 Entry 数组, Entry 是 HashMap 的基本组成单元, 每一个 Entry 包含一个 Key-value 键值对. 

    线程不安全

    简单来说, HashMap 是由 数组+链表 组成的, 数组是 HashMap 的主体, 链表是为了解决哈希冲突而存在的, 
    如果定位到的数组位置不包含链表(当前 entry 的 next 指向 null), 那么对于查找,添加等操作很快, 仅需要一次寻址即可; 
    如果定位到的数组包含链表, 对于添加操作, 其复杂度为 O(n), 首先遍历连接, 存在即覆盖, 否则新增, 对于查找操作来讲, 仍需遍历链表, 
    然后通过 key 对象的 equals 方法逐一比对查找. 所以, 性能考虑, HashMap 中的链表出现越少, 性能才会越好.

    在 jdk1.8 之后, HashMap 采用数组+链表+红黑树实现, 当链表长度超过阈值(8)时, 将链表转换为红黑树, 这样大大减少了查找时间

## 重要属性

### size

    实际存储的 key-value 键值对的个数

### cap

    键值对分配大小, 即预先准备了多少个键值对空间, 默认为 16, 容量一定是 2 的倍数, 每次扩容会进行 乘2, 至于为什么需要保证容量是 2的幂, 是为了在数组扩容
    的时候, 减少 hash 的位置变化

### loadFactor

    加载因子, 默认为 0.75, 当 size >= cap * loadFactor 时候, 会进行扩容(resize), 至于为什么是 0.75, 主要是在空间和时间上的折中选择

## 重要方法

### get(key)

    get 方法的实现相对简单, key(hashcode) -> hash -> indexFor -> 最终索引位置, 找到对应位置的 table[i], 在查看是否有链表,
    遍历链表, 通过 key 的 equals 方法比对查找对应的记录


## 重要概念

### 扩容

    为什么需要扩容?
    因为如果填充比较大, 如果一直不进行扩容, key 的哈希碰撞概率会越来越高, 这样会导致链表越来越长, 最终查找的效率会越来越低. 
    扩容的触发条件
    当 map 中实际存储的个数大于等于当前容量(初始默认为 16)乘以加载因子(默认为 0.75) 时, 进行扩容, 默认情况下, size >= 16 * 0.75 (size >= 12)
    
    扩容是一件很耗时的操作, 有 创建新数组,hash重新计算,重新排列,链表拆分 等操作


# ConcurrentHashMap

    线程安全的 Map

    jdk1.7 之前是采用 Segment + HashEntry + ReentrantLock 的方式进行实现的
    jdk1.8 中放弃了 Segment 臃肿的设计, 取而代之的采用 Node + CAS + Synchronized 来保证并发安全进行实现. 

    jdk1.8 的实现降低了锁的粒度, jdk1.7 版本的锁的粒度是基于 Segment 的, 包含多个 HashEntry, 而 jdk1.8 锁的粒度就是 HashEntry
    JDK1.8版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用synchronized来进行同步，所以不需要分段锁的概念，也就不需要Segment这种数据结构了，由于粒度的降低，实现的复杂度也增加了
    JDK1.8使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表，这样形成一个最佳拍档

## get 操作

    get 操作是不加锁的, 这也是它保证高效率的原因之一, 其不需要加锁是因为 Node 的成员 val 是使用 volatile 修饰的

## 数组用 volatile 修饰主要是保证在数组扩容的时候保证可见性