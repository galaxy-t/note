#多线程

---

### 死锁

1. 两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

2. 解决

    > 加锁顺序（线程按照一定的顺序加锁）
    
        Thread 1:
          lock A 
          lock B
        
        Thread 2:
           wait for A
           lock C (when A locked)
        
        Thread 3:
           wait for A
           wait for B
           wait for C
        
        如果一个线程（比如线程3）需要一些锁，那么它必须按照确定的顺序获取锁。它只有获得了从顺序上排在前面的锁之后，才能获取后面的锁。
        按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁(并对这些锁做适当的排序)，但总有些时候是无法预知的。
    
    > 加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）
    
    > 死锁检测
    
### 终止线程

1. 使用标志位终止线程

        public class ServerThread extends Thread {
           //volatile修饰符用来保证其它线程读取的总是该变量的最新的值
           public volatile boolean exit = false; 
       
           @Override
           public void run() {
               ServerSocket serverSocket = new ServerSocket(8080);
               while(!exit){
                   serverSocket.accept(); //阻塞等待客户端消息
                   ...
               }
           }
           
           public static void main(String[] args) {
               ServerThread t = new ServerThread();
               t.start();
               ...
               t.exit = true; //修改标志位，退出线程
           }
       }
       
2. 使用 stop() 终止线程(已经弃用)

    > 调用 stop() 方法会立刻停止 run() 方法中剩余的全部工作，包括在 catch 或 finally 语句中的，并抛出ThreadDeath异常(通常情况下此异常不需要显示的捕获)，因此可能会导致一些清理性的工作的得不到完成，如文件，数据库等的关闭。
    
    > 调用 stop() 方法会立即释放该线程所持有的所有的锁，导致数据得不到同步，出现数据不一致的问题。
    
3. 使用 interrupt() 中断线程

    > interrupt() 方法并不像在 for 循环语句中使用 break 语句那样干脆，马上就停止循环。调用 interrupt() 方法仅仅是在当前线程中打一个停止的标记，并不是真的停止线程。
    
    > 也就是说，线程中断并不会立即终止线程，而是通知目标线程，有人希望你终止。至于目标线程收到通知后会如何处理，则完全由目标线程自行决定。这一点很重要，如果中断后，线程立即无条件退出，那么我们又会遇到 stop() 方法的老问题。
    
    > 外部调用 t.interrupt(); 要求线程 t 终止
    
    > 线程内部使用 if(Thread.currentThread().isInterrupted()) 来决定是否中断线程

    