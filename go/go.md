# Golang

    Go（又称 Golang）是 Google 的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。
    Go 语言语法与 C 相近，但功能上有：内存安全，GC（垃圾回收），结构形态及 CSP-style 并发计算。

***

### 优点及特性

### 代码风格

1. go 文件的扩展名为 *.go

### 命令的使用

1. 运行一个 go 程序 : go run hello.go

2. 将 go 程序编译成当前操作系统可执行脚本 : go build hello.go

### 开发

#### 从 Hello World 开始

1. Go 语言的基础组成有以下几个部分：

    * 包声明
    * 引入包
    * 函数
    * 变量
    * 语句 & 表达式
    * 注释

    ```
    package main
       
    import "fmt"
       
    func main() {
       /* 这是我的第一个简单的程序 */
       fmt.Println("Hello World!")
    }
   ```

   ```

   让我们来看下以上程序的各个部分：
   
   1. 第一行代码 package main 定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。
   2. 下一行 import "fmt" 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。
   3. 下一行 func main() 是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。
   4. 下一行 /*...*/ 是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。
   5. 下一行 fmt.Println(...) 可以将字符串输出到控制台，并在最后自动增加换行字符 \n。
      使用 fmt.Print("hello, world\n") 可以得到相同的结果。
      Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。
   6. 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。
   
    ```

   ```
   执行
   打开 sublime , 将上述代码拷贝到编辑器中 
   将以上代码保存为 hello.go 
   打开命令行 , 并进入程序文件保存的目录中
   输入命令 go run hello.go 并按回车执行
   以上操作如果正确 , 则会打印输出 Hello World!
   还可以使用 go build hello.go 命令来生成二进制文件
   
   ```

   ```
   注意
   { 不能单独放在一行 , 否则运行时会报错
   文件名与包名没有直接关系 , 不一定要将文件名与包名定成同一个
   文件夹名与包名没有直接关系 , 并非需要一致
   同一个文件夹下的文件只能有一个包名 , 否则编译报错
   
   ```

#### 基础语法

    Go 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。如以下 GO 语句由 6 个标记组成

1. 行分隔符

    * 一行代表一个语句结束 , 不需要像 java 中以 ; 结束
    * 如果想要将多条语句放在同一行 , 则必须手动添加 ; 来进行分隔 , 但实际开发中并不鼓励这么做

2. 注释

    * 注释不会被编译 , 每一个包应该有相关注释
    * 单行注释是最常见的注释形式 , 你可以在任何地方使用以 // 开头的单行注释
    * 多行注释也叫块注释 , 均已以 /* 开头 , 并以 */ 结尾

3. 标识符

    * 标识符用来命名变量、类型等程序实体
    * 由大小写字母 , 数字 , 下划线组成 , 不能以数字开头

4. 字符串连接

    * 可以通过 + 实现字符串拼接 , 可以参考 java 的字符串拼接

5. 关键字

    * 这个此处不进行记录 , 需要后续慢慢记忆 , 如果连这些都没有印象 , 还怎么写程序 ? 这不是教程 , 这是笔记 .

6. 空格

    * 变量的声明必须使用空格隔开
    * 语句中适当使用空格能让程序更易阅读

#### 数据类型

    在 Go 编程语言中 , 数据类型用于声明函数和变量 . 
    
    数据类型的出现是为了把数据分成所需内存大小不同的数据 , 编程的时候需要用大数据的时候才需要申请大内存 , 就可以充分利用内存

1. 布尔型

    * bool

2. 数字类型

    * Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码
    * 整型
    ```
        1   uint8
        无符号 8 位整型 (0 到 255)
        2	uint16
        无符号 16 位整型 (0 到 65535)
        3	uint32
        无符号 32 位整型 (0 到 4294967295)
        4	uint64
        无符号 64 位整型 (0 到 18446744073709551615)
        5	int8
        有符号 8 位整型 (-128 到 127)
        6	int16
        有符号 16 位整型 (-32768 到 32767)
        7	int32
        有符号 32 位整型 (-2147483648 到 2147483647)
        8	int64
        有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)
    ```
    * 浮点型
    ```
        1	float32
        IEEE-754 32位浮点型数
        2	float64
        IEEE-754 64位浮点型数
        3	complex64
        32 位实数和虚数
        4	complex128
        64 位实数和虚数
    ```
    * 其他数字类型
   ```
       1	byte
       类似 uint8
       2	rune
       类似 int32
       3	uint
       32 或 64 位
       4	int
       与 uint 一样大小
       5	uintptr
       无符号整型，用于存放一个指针
   ```

3. 字符串类型

    * 字符串就是一串固定长度的字符连接起来的字符序列
    * Go 的字符串是由单个字节连接起来的
    * Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本

4. 派生类型

    * 指针类型（Pointer）
        * 使用 & 获取一个变量的指针, 如: &name
        * 使用 * 获取一个指针对应的内容, 如: a := &name; b := *a
    * 数组类型
        * var a [3]int
        * var b [3]int = [3]int {1, 2, 3}
        * var c [3]int = [3]int {1, 2}
        * d := [...]int{1, 2, 3}    如果出现 ... 则代表数组的长度是根据初始化值的个数来计算
        * 数组中的每一项都会被初始化, 如以上的各个数组中每一个值都是 0
        * 比较两个数组是否相等, 可以使用 (== 和 !=) 来判断两个数组是否相等, 只有两个数组中的所有元素都是相等的时候数组才是相等的, 也只能比较两个类型相同的数组, 不能比较两个类型不同的数组
        * 获取数组中的某个元素, 如: a[0], a[1]
    * 切片类型 (Slice)
        * 切片是对数组的一个连续片段的引用, 所以切片是一个引用类型
        * 从连续内存区域生成切片是常见的操作, 如: slice[开始位置: 结束位置], slice: 表示目标切片对象, 开始位置: 对应目标切片对象的索引, 结束位置: 对应目标切片对象的结束索引(不包含)
        * 切片有 len: 长度 cap: 容量 等属性, 如: a := []int{1, 2, 3} 得到一个切片 a, a 的长度为 3, 容量也为 3, 如果使用 append() 函数为其添加一个元素, 那么其长度会变为 4, 容量会变为 6
        * 如从一个数组中得到一个切片, a := [3]int{1, 2, 3}; fmt.Println(a, a[1:2]); 结果: [1 2 3]  [2], 其中 [2] 就是 a[1: 2] 切片操作的结果
            * 取出的元素数量为：结束位置 - 开始位置；
            * 取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取；
            * 当缺省开始位置时，表示从连续区域开头到结束位置；
            * 当缺省结束位置时，表示从开始位置到整个连续区域末尾；
            * 两者同时缺省时，与切片本身等效；
            * 两者同时为 0 时，等效于空切片，一般用于切片复位。
        * 声明一个新的切片 var name []Type, name 为切片的变量名, Type 为切片对应的元素类型, 与数组的差别为不指定长度
        * 注意: 切片为引用传递, 改变切片的值内容即改变目标切片或目标数组的值内容
        * 可以使用 len() 方法得到切片的长度
        * 可以使用 make() 函数动态的创建一个切片
        * 可以使用 append() 函数为切片添加元素
        * 可以使用 cap() 函数得到切片的容量
        * 从切片中删除元素, go 语言并没有提供用于删除切片元素的语法或接口, 需要使用切片本身的特性来删除元素,
            * 从开头删除 a = []int{1, 2, 3};
                * a = a[1:]; // 删除开头1个元素 a = a[N:]; // 删除开头N个元素
                * 也可以不移动数据指针, 可以使用 append 原地完成, a = append(a[:0], a[1:]...); // 删除开头1个元素  a = append(a[:0], a[N:]...) // 删除开头N个元素
            * 从中间删除
                * a = append(a[:i], a[i+1:]...) // 删除中间1个元素
                * a = append(a[:i], a[i+N:]...) // 删除中间N个元素
            * 从尾部删除
                * a = a[:len(a)-1] // 删除尾部1个元素
                * a = a[:len(a)-N] // 删除尾部N个元素
    * Map 类型
        * 结构与 java 的结构一致
        * 创建一个 map, a := make(map[string]int)
        * 为 map 添加两个键值对, a["key1"] = 1; a["key2"] = 8;
        * 获取 map 中某键对应的值, fmt.Println(a["key1"]); fmt.Println(a["key2"]);
        * 若尝试使用一个不存在的键获取值, 则返回结果通常为值对应的默认值
        * 未初始化的 map 的值是 nil，使用函数 len() 可以获取 map 中 pair 的数目
        * 使用 delete() 函数删除一个键值对
        * go 语言没有提供清空 map 的方法, 清空 map 的唯一方法就是重新构造一个新的 map, 不用担心垃圾回收的效率, Go语言中的并行垃圾回收效率比写一个清空函数要高效的多
        * Go语言中的 map 在并发情况下，只读是线程安全的，同时读写是线程不安全的。
        * sync.Map() 是 Go 1.9 版本中提供的一种效率较高的并发安全的 map, 与常规 map 不同, 不是以语言原生形态提供, 而是在 sync 包下的结构, 并且不能使用 map 的方式进行取值和设置等操作
          而是使用 sync.Map 的方法进行调用，Store 表示存储，Load 表示获取，Delete 表示删除。
    * 列表(list)
        * 在Go语言中，列表使用 container/list 包来实现，内部的实现原理是双链表，列表能够高效地进行任意位置的元素插入和删除操作。
        * 初始化列表
            * 通过 container/list 包的 New() 函数初始化 list, 变量名 := list.New();
            * 通过 var 关键字声明初始化 list, var 变量名 list.List
        * 向列表中插入元素
            * a.PushFront(1) 在队列前方插入元素
            * a.PushBack(2) 在队列后方插入元素
            * 这两个方法都会返回一个 *list.Element 结构, 其实就是当前插入的值被封装之后的对象, 如果在以后使用中需要删除插入的元素则需要用其配合 Remove() 方法进行删除
        * 便利集合中的每一个元素
            * for i := a.Front(); i != nil; i = i.Next() {
              fmt.Println(i.Value)
              }
    * 结构化类型(struct)
        * 可以理解为 java 中的实体类
        * 创建一个结构体, 以下创建了一个名为 Point 的结构体, 其有两个属性(字段), X,Y, 都是 int 类型
            type Point struct {
                X int
                Y int
            }
        * 实例化, 结构体被初始化之后, 其字段的默认值是字段类型的默认值, 如: int 为 0, 字符串为 ""(空字符串), 布尔为 false, 指针为 nil 等
            * 创建一个对象
              var p1 Point
              p1.X = 10
              p1.Y = 20
            * 创建指针类型的结构体, p2 为对象的指针
              p2 := new(Point)
              p2.X = 10
              p2.Y = 20
            * 取结构体的地址实例化, p3 为对象的指针, 对结构体进行 & 取地址操作时, 是为对该类型进行一次 new 的实例化操作, 是最广泛的一种结构体实例化方式
              p3 := &Point{}
              p3.X = 10
              p3.Y = 20
        * 初始化
            * 使用“键值对”初始化结构体
              p3 := &Point{
              X: 10,
              Y: 20,
              }
            * 使用多个值的列表初始化结构体, 必须初始化结构体的所有字段, 每一个初始值的填充顺序必须与字段在结构体中的生命顺序一致, 键值对与值列表的初始化形式不能混用
              p4 := Point{10, 20}
              p4.X = 10
              p4.Y = 20
    * Channel 类型
    * 函数类型
    * 接口类型（interface）


#### 变量声明

    变量来源于数学 , 是计算机语言中能储存计算结果或能表示值抽象概念
    
    var 变量名 类型 , 如 : var str string = "hello"
    指定变量类型 , 不进行初始化赋值 , 那么该变量会根据不同的类型初始化默认值 , 如 : var str string
    根据值自行判断类型 , 如 : var str = "hello" , 如此 , 编译器会自动判断 str 这个变量的类型为 string
    省略 var , 如 : str := "hello" , 要求前面没有声明过 str 这个变量 , 注意是 := 而不是 = , 这种写法函数体内 , 不可以用于全局变量的声明和复制 , 使用操作符 := 可以高效地创建一个新的变量 , 称之为初始化声明
    局部变量一旦定义则必须使用 , 否则编译时会报错 , 全局变量允许声明但不使用
    如果想交换两个变量的值可以简单使用 : a , b = b , a    , 两个变量的类型必须相同
    _ 这个特殊变量后期再了解一下

#### 常量

    常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型
    const 常量名 [类型] = 值
    类型可以省略 , 编译器会根据值来自行推断类型
    常量还可以用作枚举
        const (
            Unknown = 0
            Female = 1
            Male = 2
        )
    常量可以用 len() , cap() , unsafe.Sizeof() 函数计算表达式的值
    常量表达式中 , 函数必须是内置函数 , 否则编译不通过
    iota 这个后期再了解一下

#### 运算符

    算术运算符
    + - * / % ++ --     同 java
    关系运算符
    == != > < >= <=     同 java
    逻辑运算符
    && || !             同 java
    位运算符
    & | ^               同 java
    赋值运算符
    = += -= *= /= %= <<= >>= &= ^= |=   同 java
    其他运算符
    &	返回变量存储地址	如 : &a; 将给出变量的实际地址。
    *	指针变量 	    如 : *a; 是一个指针变量
    
    注 : go 语言中没有三目运算符

#### 条件语句

    if else if 与 java 中的基本上相同, 没啥区别
    switch  与 java 中存在很大的不同, case 的条件可以有多个, 不需要 break ,因为它不会顺序执行其他的 case, 如果需要顺序执行下去, 那么则需要使用 fallthrough 关键字
    select  新东西
    
    注 : 条件不需要用 () 包裹

#### 循环语句

    go 语言中的循环语句只支持 for, 与 java 的比较类似

    for i := 0; i < 10; i++ {
    
    }

    break continue 

    goto, 在多层循环的时候可以直接使用 goto 关键字跳转到某个标签, 以下示例使用 goto 跳转到 abcd 标签出, 可以直接打断所有循环, 如果循环结束没有被 goto, name, abcd 的代码最终依然会被执行
    for i := a.Front(); i != nil; i = i.Next() {
        if i == nil
		    goto abcd
	}

	abcd:
		fmt.Println("kljsdjhflkdsjf")

    
###

#### defer

    使用 defer 语句会将后面跟随的语句进行延迟处理, 在 defer 归属的函数即将返回时, 将延迟处理的语句按 defer 的逆序进行执行, 也就是说, 先被 defer 的语句最后被执行, 最后被 defer 的语句, 最先被执行.

    func main() {
        fmt.Println("defer begin")
        defer fmt.Println(1)
        defer fmt.Println(2)
        fmt.Println("defer end")
    }
    
    以上执行结果:
    defer begin
    defer end
    2
    1

    结论: 先执行不被 defer 的语句, 然后倒叙执行 defer 的语句

#### panic(宕机)

    Go语言可以在程序中手动触发宕机，让程序崩溃，这样开发者可以及时地发现错误，同时减少可能的损失。
    当 panic() 触发的宕机发生时，panic() 后面的代码将不会被运行，但是在 panic() 函数前面已经运行过的 defer 语句依然会在宕机发生时发生作用

    func main() {
        defer fmt.Println("宕机后要做的事情1")
        defer fmt.Println("宕机后要做的事情2")
        panic("宕机")
    }

    运行结果: 
    宕机后要做的事情2
    宕机后要做的事情1
    panic: 宕机
    
    goroutine 1 [running]:
    main.main()
    D:/dev/go/mall/test/test5/test.go:9 +0xac

    结论: 宕机前，defer 语句会被优先执行，由于第 7 行的 defer 后执行，因此会在宕机前，这个 defer 会优先处理，随后才是第 6 行的 defer 对应的语句，这个特性可以用来在宕机发生前进行宕机信息处理。
    
#### recover

    Recover 是一个Go语言的内建函数，可以让进入宕机流程中的 goroutine 恢复过来，recover 仅在延迟函数 defer 中有效，在正常的执行过程中，调用 recover 会返回 nil 并且没有其他任何效果，如果当前的 goroutine 陷入恐慌，调用 recover 可以捕获到 panic 的输入值，并且恢复正常的执行。

#### errors(go语言中的异常)

    异常接口的定义, 其类型为一个字符串
    type error interface {
	    Error() string
    }

    返回错误钱, 需要定义产生哪些可能的错误, 在 go 语言中, 使用 errors 包进行错误的定义, 格式如下: 
    var err = errors.New("this is an error")
    错误字符串由于相对固定，一般在包作用域声明，应尽量减少在使用时直接使用 errors.New 返回。

    // 定义除数为0的错误
    var errDivisionByZero = errors.New("division by zero")
    func div(dividend, divisor int) (int, error) {
        // 判断除数为0的情况并返回
        if divisor == 0 {
            return 0, errDivisionByZero
        }
        // 正常计算，返回空错误
        return dividend / divisor, nil
    }
    func main() {
        fmt.Println(div(1, 0))
    }

    若最终 divisor 不为 0, 则 error 返回 nil



### 常用方法

#### len()

    go 语言内置长度函数, 用于得到数量
    如果用于计算字符串的数量, 那么它返回的是字符串中字节的数量

#### utf8.RuneCountInString()

    用于获取字符串中字符的数量

#### strconv

    字符串转换包

    strconv.Atoi()  将字符串转换成 int
	strconv.Itoa()  将 int 转换成字符串
	
	strconv.ParseBool()     将字符串转换成 Bool
	strconv.ParseFloat()    将字符串转换成 Float
	strconv.ParseInt()      将字符串转换成 Int
	strconv.ParseUint()     将字符串转换成 Unit

    strconv.FormatBool()    将 Bool 转换成字符串
    strconv.FormatInt()     将 Int 转换成字符串
    strconv.FormatUint()    将 Uint 转换成字符串
    strconv.FormatFloat()   将 Float 转换成字符串

    将原始类型转换成字符串并追加到一个切片中
    strconv.AppendInt()
    strconv.AppendBool()
    strconv.AppendFloat()
    strconv.AppendUint()

#### range

    用于 迭代循环 操作
    for k, v := range team {
        fmt.Println(k, v)
    }
    k: 下标, 从 0 开始
    v: 下标对应元素的值

#### make()

    用于动态的创建一个切片

    make([]Type, size, cap)
    Type: 切片的元素类型, size: 为这个切片分配多少个元素, cap: 预分配的元素数量, cap设定后不影响 size, 只是能提前分配空间, 降低多次分配空间的性能问题

#### append()

    用于为切片动态添加元素
    var a []int
    a = append(a,1)     // 追加一个元素 1
    a = append(a, 1, 2, 3)  // 追加多个元素, 手写解包方式
    a = append(a, []int{1,2,3}...) // 追加一个切片, 切片需要解包

#### cap()

    用于得到切片的容量, 注意该容量并不等于切片的长度
    在使用 append() 为切片动态添加元素时, 如果空间不足以容纳足够的元素, 切片就会进行扩容, 扩容的时候会改变切片的容量
    切片在扩容时, 容量的扩展规律是按容量的 2 倍数进行扩充, 如: 1, 2, 4, 8, 16......

#### copy()

用于将一个数组切片复制到另一个数组切片中

#### delete()

用于删除 map 中的一个键值对
delete(a, "key1")

   

