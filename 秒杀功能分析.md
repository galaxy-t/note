# 秒杀功能分析
    
    在我的面试生涯中总能碰到一些高并发及其可能会存在的一些隐患问题，比如：数据的一致性，线程安全，数据库脏读，各种压力等。
    拿到具体场景中来看，电商平台的秒杀功能其实几乎囊括了以上大部分的问题，并且更具有研究的拓展性。
    以下针对秒杀功能进行一些分析及技术理论上的支持。
    PS：本篇文章并未进行过任何的测试及实现，本人也并未参与过任何高并发项目的开发（遗憾），本文仅作为理论性提供一些本人的想法而已。
    仅供参考
    
### 秒杀业务分析

    1. 在秒杀开始之前的一段时间，高频率的刷新商品抢购页面
    
    2. 在秒杀活动开始的一瞬间放开流量
    
    3. 商品被瞬时售空
    
    4. 时间短、瞬时并发量高

    以下逐条分析并提供上述问题的解决方案
    
1. 假设某电商网站秒杀活动只推出一件或几件商品，预计会有1万人参加，也就是说最大并发请求书是1万，但其实平时的访问量可能仅有几百，
   由此可以看出秒杀功能对现有网站业务会造成冲击，秒杀活动只是网站营销的一个附加活动，这个活动具有时间段，并发访问量大的特点，如果和
   原有应用部署在一起，必然会对现有业务造成冲击，稍有不慎可能会导致整个网站瘫痪。
   
   > 解决反感：将秒杀系统独立开发部署，甚至使用独立域名，使其与原网站完全隔离。
   
2. 活动开始之前高频率的访问量，实际场景下，用户在活动开始之前的一分钟内不断的刷新页面，以达到及时能够刷新出抢购按钮的激活状态，
   尤其是商品详情类的页面，因为存在大量的图片，每个页面的都可能不会太小。
   
   > 将抢购页面静态化，使其压力不再放到应用服务器上
   
   > 将页面进行压缩，尽可能的减小流量对带宽的占用
   
   > 将 css js 文件进行 CDN 加速
   
   > 将图片文件放到图片服务器上，同样也进行 CDN 加速，且做负载、集群等部署
   
   > 将页面内容缓存到本地浏览器，同一时间段内访问的都是本地数据
   
3. 抢购按钮激活，现在的抢购功能的页面上一般都会在抢购时间开始的时候被激活。

    > 可以使用 js 的定时器来控制抢购按钮的激活
    
    > 此处涉及到时间同步问题，即本地时间与服务器时间存在不一致的情况，即使各服务器之间也不一定能够做到同步，可以提供几台单独的
      服务器提供统一时间 API 接口，因为该接口不需要验证等逻辑，也不需要操作数据库，每次请求仅需要响应一条时间戳即可，
      所以几台服务器基本上可能承载相当大的并发量，每台服务器及每个客户端定时获取服务器时间
      
4. 下单 API 暴露问题，很多有心人士很可能查看页面源代码找到下单的 API 链接，然后自己写一个模拟客户端来进行循环并发抢单，
   或者一些黑客可以控制几万台肉鸡进行抢单也有可能
   
   > 可以在请求的 URL 提供服务器生成的随机数，以验证请求的合法性
   
5. 一般的抢购功能，大多都是查多，增少这种情况，可以使用一些缓存或非关系型数据库提供读操作的查询，像 Redis ，单秒几万的并发，
   应对起来也是很容易的
   
6. 下单接口访问量瞬间暴涨，使服务器压力过大

    > 限流，漏桶、令牌桶选一个，在抢购功能里，限流的最大功能就是让 99% 的流量失效，以避免对后端的服务造成过大的压力，此时可以
      给予客户端以友好的提示
      
    > 队列，可以自己实现，也可以使用一些第三方的队列，自己实现的话，参考以下几个队列包，ArrayBlockingQueue(初始容量固定的阻塞队列，可以用来作为数据库模块成功竞拍的队列，比如有十个商品，那么我们就设定一个10大小的队列)、
      ConcurrentLinkedQueue(使用的是 CAS 原则无锁队列实现，是一个异步队列，入队速度快，出队加锁，性能稍慢)、
      LinkedBlockingQueue(阻塞队列，入队和出队都加了锁，当队列为空的时候线程会暂时阻塞)
      因为我们的需求，入队速度要求大于出队速度，一般也不会出现队列为空的情况，所以我们可以选择 ConcurrentLinkedQueue;
      第三方的队列选择性就比较多了，此处不做赘述
      
    > 队列处理完之后通过异步的方式通知前端页面，如 WebSocket 
      
7. 在下单功能中，可能出现过量销售的情况，比如库存为10，但是却卖出了12件，这种脏读的情况

    > 乐观锁
    
    > 悲观锁
    
    > 以上两种限于数据库的能力，而且也可能出现各种各样的情况，悲观锁很容易将表锁死这就太坑了
    
    > Redis 搭配 Lua 脚本保证不会出现脏读的情况，Redis 单核单线程，天生的线程安全，天生的原子性，写一段 Lua 脚本，
      把下单逻辑写进去，一切 OK 了，写个定时任务或者其它的方式将缓存的数据再刷新到数据库中去，此时应该注意 Redis 的主从，怎么也得是 2 * 3 这样子的规模
      

